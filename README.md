# pragmatic-unit-testing

"자바와 junit을 활용한 실용주의 단위 테스트" 스터디

## 단위 테스트의 범위

* 시스템에서 유용한 행동을 하는 작은 코드
* 끝에서 끝(end-to-end)까지 행동을 의미하지는 않음

## 단위 테스트를 작성해야 하는 상황과 이유

* 어떤 기능을 막 코딩했고 그것이 예상한 대로 작동하는지 않고 싶습니다.
* 코드를 변경하고 기종 동작을 깨뜨리지 않았는지 확인 하고 싶습니다.
* 서드 파티 코드가 더 이상 기대한 대로 동작하지 않을 때를 알고자 합니다.
* 시스템의 현재 동작을 이해하고 싶습니다.
* 시스템에 작성한 변경 사항을 문서화하여 자신과 다른 사람들이 나중에 이해하도록 하고 싶습니다.
* 프로덕션 시스템 배포에 대한 자신감을 높여줍니다.

## 어떤 테스트를 작성할 수 있는지 결정

* 반복문, if문과 복잡한 조건문들을 보는 것
* 데이터 변형도 고려, null, 0, empty 값이 전달되었을때
* 스스로 코드를 작성하며 파악한 테스트 필요 영역

## 테스트 작성법

* 준비(arrange), 실행(act), 단언(assert). AAA 혹은 트리플 A라고 부르는 테스트 코드 작성 템플릿? 패턴을 따른다.
* 우선 실패하는 테스트 코드를 작성한다.
* 테스트 메소드 이름은 의도를 담을 수 있는 적절한 이름으로 정한다.
* 테스트의 유지보수성도 고려(테스트 코드 역시 리팩토링 대상이다)
* 중복된 초기화 코드는 @Before 등을 이용하여 제거하자.
* JUnit은 결정된 순서로 테스트를 실행하지 않는다.
* JUnit에서 각 단위 테스트는 고유 맥락을 갖는다.
* 모든 테스트는 다른 테스트 결과에 영향을 받지 않는다.
* 테스트 별로 인스턴스 생성, 독립적이다.
* 테스트가 독립적이지 않고 상호 의존성 존재시 디버깅의 어려움이 발생된다.

## JUnit 단언

* 테스트에서 정적 메서드 호출을 통해 조건의 참인지 검증하는 방법
* 조건이 참이 아니면 테스트는 실패(failure)
* 예외가 발생하고 catch하지 않은 경우는 오류(error)
* 두가지 단언 스타일 존재, 기본적인 스타일의 단언은 JUnit에 포함, 표현이 풍부한 햄크래스트(hamcrest)를 이용한 단언(matchers 라는 단어의 철자 순서 변경)
* 둘중 한 가지를 선택하면 좋다
* 테스트에서 광범위하게 사용되기 때문에 static import를 사용
* 테스트 코드는 특정 사례의 검증을 하기 때문에 기댓값 또한 명시적 지정이 낫다 (범위지정보다)

## AAA or AAAA

* 준비(arrange) 테스트 코드를 실행하기 전에 시스템이 적적할 상태로 만듭니다.(예 객체생성등)
* 실행(act) 테스트 코드를 실행합니다.
* 단언(assert) 실행항 코드가 기대한 대로 동작하는지 확인합니다.
* 사수(after) 테스트를 실행할 때 어떤 자원을 할당했다면 회수를 진행합니다.

## 동작 테스트 vs 메서드 테스트

* 테스트를 작성할때 개별 메서드를 테스트 한다고 생각하지 말고
* 클래스의 종합적인 동작을 테스트 해야한다.
* 예 은행 ATM 클래스 입금(), 출금(), 잔액조회()

## 테스트와 프로덕션 코드의 관계

* 테스트는 프로덕션 코드와 분리해야합니다.
* 분리하지 않는다면 JAR 파일이 커지고 코드 베이스의 공격 표면이 늘어 납니다.
* 단위 테스트 일방향성 입니다. 테스트 코드는 프로덕션 코드를 의존하지만 프로덕션 코드는 테스트 코드의 존재를 모릅니다.
* 하지만 테스트는 프로덕션 시스템의 설계에 영향을 줍니다.
* 테스트 친화적인 설계를 채택할수록 편해지고 설계도 좋아집니다.

## 테스트와 프로덕션 코드 경로 3가지

### 같은 디렉터리 및 패키지에 넣기

* 어느 누구도 실제 시스템에 이렇게 하지 않습니다.
* 배포를 하기위해 테스트 코드를 걷어 내는 스크립트, 리플랙션 코드가 필요 할것입니다.

### 별도 디렉터리에 같은 패키지에 넣기

* 대부분의 회사에서 이것을 선택합니다(예 메이븐 프로젝트)
* 동일한 패키지를 가지므로 패키지 수준의 접근 권한을 가집니다. (장단점 존재)

### 별도 디렉터리에 같지 않은 패키지에 넣기

* 패키지가 다르므로 공개(public) 인터페이스만 활용하여 테스트 코드를 작성합니다.
* 어떤 개발자들은 테스트를 작성할 때 프로덕션 코드의 public 인터페이스만 사용해야 한다고 믿습니다. public이 아닌 메서드를 테스트 코드에서 호출하면 정보은닉(infomation hiding) 원칙을
  위배한다고 생각합니다.
* 비공개 코드를 호출하는 테스트는 구현 세부 사항과 의존하게 됩니다.
* 테스트 작성을 위해 과도하게 사적인 질문(의역 package private 메소드 호출)을 할 수 있습니다.
* 내부 행위를 테스트하려는 충동이 든다면 설계에 문제가 있는지 살펴봐야 합니다. (예 SRP)
* 흥미로운 private 메서드를 추출하여 다른 클래스로 이동

## 단일 목적 테스트의 가치

짧은 테스트 코드를 하나의 테스트 코드로 합친다면?  
공통 초기화의 부담을 줄일 수 있을지 모르나 JUnit이 제공하는 테스트 고립의 중요한 이점을 잃게됩니다. 테스트 이름 또한 일반적이고 의미를 잃어갑니다.

### 테스트를 분리하면 얻는 이점

* 단언이 실패했을 때 실패한 테스트 이름이 표시되기 때문에 어느 동작에서 문제가 있는지 빠르게 파악
* 별도의 인스턴스로 실행하기 때문에 실패한 테스트를 해독하는 데 필요한 시간을 줄일 수 있습니다.
* 모든 케이스가 실행되었음을 보장할 수 있습니다. 단언이 실패하면 현재 테스트 메서드는 중단됨.
* java.lang.AssertionError 를 throw

## 문서로서의 테스트

* 단위테스트는 우리가 만드는 클래스의 지속적이고 믿을 수 있는 문서 역할을 해야합니다.
* 어떤 의미에서는 테스트가 없었으면 주석으로 적어 놓았을 많은 내용을 보충하기도 합니다.
* when~~~then~~~ 형태의 이름을 사용합니다.
* 합의된 형태의 이름을 일관성있게 유지하는 것이 중요합니다.
* 다른 사람이 파악 가능한 수준으로 리팩토링을 고려합니다.

## Before, After, BeforeClass, AfterClass 공통 초기화와 정리 더 알기

* 초기화 대상이 여러개 라면 Before 메소드를 분리 합시다. 순서는 보장되지 않음
* After 메소드는 테스트를 한 후 실행 테스트가 실패 하더라도 실행됩니다. 테스트에서 발생하는 부산물 정리하는 역할을 합니다. 예 DB커넥션 해제, 파일 삭제
* 실행 흐름을 숙지합니다.

```
@BeforeClass
constructor
@Before
@Test
@After
@AfterClass
```

## 녹색이 좋다: 테스트를 의미 있게 유지

* 실패하는 테스트가 있다면 즉시 테스트가 통과되도록 합시다.
* 전체 테스트 결과의 피드백을 받습니다. 빌드툴, 백그라운드에서 테스트를 항상 실행하는 도구를 고려합시다.
* 전체 테스트가 어렵다면 패키지 단위 실행을 해도 좋습니다.
* 테스트는 빨라야 합니다.
* 동작하지 않는 테스트는 @Ignore 처리 합시다. 제외된 테스트를 알려주기 때문에 잊지 않을 수 있습니다.다만 최소한으로 사용해야 할것입니다.

## 나쁜 테스트의 조건

* 테스트를 사용하는 사람에게 어떤 정보도 주지 못하는 테스트
* 산발적으로 실패하는 테스트
* 어떤 가치도 증명하지 못하는 테스트
* 실행하는 데 오래 걸리는 테스트
* 코드를 충분히 커버하지 못하는 테스트
* 작은 변화에도 다수의 테스트가 실패하는 구현과 강하게 결합되어 있는 테스트
* 수많은 설정 고리로 점프하는 난해한 테스트

## FIRST : 좋은 테스트의 조건

* [F]ast:빠른
* [l]solated:고립된
* [R]epeatable:반복 가능한
* [S]elf-validating:스스로 검증 가능한
* [T]imely:적시의

### [F]IRST: 빠르다

빠른 테스트는 코드만 실행, 소요 시간은 수 밀리초 수준 느린 테스트는 외부 자원을 다루는 코드를 호출(데이터베이스, 파일, 네트워크), 실행 시간은 수십, 수백, 수천 밀리초 소요 단위 테스트를 하루에 서너 번
실행하기도 버겁다면 무언가 잘못된것. 시스템에 대한 지속적이고 종합적인 빠른 피드백을 주지 못하면 단위 테스트 스위트의 가치는 그만큼 저하됩니다.

테스트를 빠르게 유지하세요! 설계를 깨끗하게 하면 빠르게 유지할 수 있습니다. 가장 먼저 느린 테스트에 대한 의존성을 줄이세요. 이러한 의존성을 최소화하는 것 역시 좋은 설계의 목표입니다. 다시 한 번 말하지만,
코드를 클린 객체 지향 설계 개념과 맞출수록 단위 테스트 작성도 쉬워집니다.

### F[I]RST : 고립시킨다

좋은 단위 테스트는 검증하려는 작은 양의 코드에 집중합니다. 직접적 혹은 간접적으로 테스트 코드와 상호 작용하는 코드가 많을수록 문제가 발생할 소지가 늘어납니다.

또 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않습니다. 따라서 테스트 코드는 어떤 순서나 시간에 관계없이 실행할 수 있어야 합니다. 각 테스트가 작은 양의 동작에만 집중하면 테스트 코드를 집중적이고 독립적으로
유지하기 쉬워집니다.

또 SRP는 테스트 메서드에서도 훌륭한 지침을 제공합니다. 테스트 메서드가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것도 고려해 보세요.

### FI[R]ST : 반복 가능해야 한다

반복 가능한 테스트는 실행할 때마다 결과가 같아야 합니다.

### FIR[S]T : 스스로 검증 가능하다

테스트는 기대하는 것이 무엇인지 단언하지 않으면 테스트가 아닙니다.

### FIRS[T] : 적시에 사용한다

단위 테스트는 좋은 습관. 양치처럼 "이번 한 번만”이라고 하면서 건너뛰고 싶은 이유를 찾고 미루기 쉽다. 단위 테스트로 코드를 검증하는 것을 미룰수록 그것을 되돌려 테스트를 작성하기는 더욱 힘들어집니다.

많은 테스트에 중독된 개발 팀의 단위 테스트에 관한 규칙은 엄격합니다. 리뷰 프로세스, 테스트가 없을 때 코드를 거부하는 자동화된 도구도 사용합니다. 마지막으로 옛날 코드에 대한 테스트는 시간 낭비가 될 수도, 그
노력을 좀 더 말썽이 많고 역동적인 부분에 시용하세요.

## 테스트 자동화

테스트는 스스로 검증 가능할 뿐만 아니라 준비할 수도 있어야 합니다. 테스트를 실행하기 전에 수동으로 준비 단계를 만드는 어리석은 짓은 하지 마세요. 테스트에 필요한 어떤 설정 단계든 자동화를 해야 합니다.

때때로 수동으로 실행할 수도 있지만 한 단계 나아가 보면 테스트를 언제 어떻게 실행할지도 자동화할 수 있습니다. 이클립스 혹은 인텔리제이 IDEA 를 사용한다면 Infinitest 같은 도구를 고려해 볼 수
있습니다.

좀 더 큰 규모에서는 젠킨스 혹은 TeamCity 같은 지속적 통합(CI) 도구를 사용할 수도 있습니다. 이상적으로 만들어 낼 수 있는 모든 변화에 대한 테스트를 작성하는 시스템을 상상해 보세요. 코드를 소스
저장소에 통합할 때마다 빌드가 자동으로 수행되고 모든 테스트를 실행합니다(단위 테스트와 그 밖의 다른 테스트). 또 시스템이 허용 가능한 수준으로 건강한지 알려 줍니다. 빌드 서버는 확신 정도를 판단하고. 한 단계
나아가 프로덕션 시스템에 변경 사항을 반영합니다.

## 목 객체 사용

테스트 대상 코드 내부에서 외부 HTTP API를 호출을 하고 있다면 다음 두 가지 시사점이 있습니다.

* 실제 호출에 대한 테스트는 나머지 빠른 테스트들에 비해 속도가 느릴것입니다
* 외부 API는 통제 밖이므로 HTTP API가 항상 가용한지 보장할 수 없습니다

의존성이 있는 코드를 분리하여 메서드의 로직에 관한 단위 테스트를 시도 합시다. 테스트 용도로 하드 코딩한 값을 반환하는 구현체를 스텁(stub)이라고 합니다.

의존성 주입(dependency injection) 기법을 활용하여 외부 의존 코드를 스텁(stub)으로 교체 합니다. 의존성 주입을 위해 설계 변경도 가능하며 결합도를 느슨하게 만들어 설계가 더 좋아질 수
있습니다.

만약 설계를 변경하는 것이 마음에 들지 않는다면 의존성 주입 도구를 사용하여 설계 변경없이 목(mock)을 주입 할 수 있습니다.

목(mock)은 의도적으로 흉내 낸 동작을 제공하고 수신한 인자가 모두 정상인지 여부를 검증하는 일을 하는 테스트 구조물입니다.

모키토(Mockito)는 목(mock) 객체를 도입하여 고통을 주는 협력자에 대한 의존성을 끊는 방법과 항상 존재하는 장애물을 넘을 수 있게 도와주는 도구이며 DI 기능도 제공합니다.

목을 도입하면 테스트 커버리지에서 간극(gap)을 형성할 수 있음을 인지해야 합니다. 실제 클래스의 종단 간 테스트(아마도 통합 테스트)가 있는지 확인 합시다.

## 개발 초기 나쁜 코드를 정리하지 않는 이유

* 항상 처리해야할 업무가 쌓여있다.
* 내가 작성한 코드는 이미 가독성이 괜찮다는 생각. 부족하다면 주석으로 보완한다.
* 큰 변화가 필요할때 코드 리팩토링을 계획한다.
* 코드 리팩토링시 발생할 오류의 두려움.

## 테스트 주도 개발(TDD, Test-Driven Development)에 기반을 둔 단위 테스트 전략의 핵심

작성하려는 코드가 있다면 코드를 작성한 후에 어떻게 테스트할지 고민하기보다 항상 먼저 어떻게 그 코드를 테스트할지 고민해야 한다.

## TDD의 이점

따라서 TDD 를 채택하면 소프트웨어 설계는 아마도 더 좋아질 것이다. TDD 에서는 코드가 변경될 것이라는 두려움을 지울 수 있다. 코드를 지속적으로 발전시킬 수 있는 자유를 줍니다.

## TDD의 사이클

* 실패하는 테스트 코드 작성
* 테스트 통과시키기
* 코드 리팩토링

## TDD의 리듬

10 분정도의 시간 제한을 걸어 리듬을 형성하려는 시도도 좋다.

## 테스트 코드 작성시 기억 할 부분

TDD 로 생각하는 부분의 일부는 다음 작성할 테스트를 결정하는것입니다. 프로그래머로서 임무는 모든 가능한 시나리오를 이해하는 것입니다. 이들 시나리오를 테스트로 만들고 각 테스트를 통과하게 만드는 코드 증분을
최소화하는 순으로 코드를 작성하는 것입니다. 테스트를 리팩토링하면 TDD 사이클을 짧게 유지하는 데 도움을 줍니다. 테스트 이름이 깔끔하고 일관성이 있을수록 더 신뢰할 수 있는 클래스 문서가 될 것입니다.

## 단위테스트 도입

단위 테스트 작성을 즐기고 새로운 코드에 잘 적용할 수 있다고 해도 보통은 힘든 싸움에 직면합니다. 아마 팀 동료는 테스트 코드 작성을 소흘히 할 수 있습니다. 혹은 마감 시간이 다가올 때 시간을 맞추는 유일한
방법은 보호 장치를 거두는 것이라고 주장할 수도 있습니다.

단기간에 이득을 얻기위해 품질을 떨어뜨리는 선택은 큰 대가를 치를 것. 테스트 없이 코드를 만드는 것은 매우 단기간에만 생산적. 변함없이 디버깅해야 하는 결함들과 마주할 것. 그리고 급조한 코드를 변경하는 데 더
많은 시간이 들고 코드도 이해하기 어려워짐.

첫날부터 품질을 통제하며 개발하길 주장하면 이러한 벽에 부딪히는 횟수를 줄일 수 있습니다. 어떻게 단위 테스트가 팀 문화의 일부가 될 수 있을지 토론해 보세요.

## 팀과 같은 편 되기

단위 테스트에 접근하는 방식은 개인별로 다릅니다. 책에서 읽은 권장 사항을 모든 사람이 동의하지는 않는다는 점입니다. 언쟁 대신 동의하고 합의점을 늘려 가는 방향으로 나아가야 합니다. 팀이 같은 편이 되는 것이
중요합니다.

### 단위테스트 표준만들기

초창기에 표준화해야 하는 목록은 다음과 같습니다.

• 코드를 체크인하기 전에 어떤 테스트를 실행해야 할지 여부 • 테스트 클래스와 메서드의 이름 짓는 방식 • 햄크레스트 혹은 전통적인 단언 시용 여부 • AAA 사용 여부 • 선호하는목 도구선택

대부분의 팀들은 적어도 분기별로는 표준들을 다시 살피고 고쳐야 합니다.

### 코드 리뷰로 표준 준수

표준을 준수하는 것은 쉽지 않습니다. 팀은 대다수 동료에게 압박을 조금 가할 필요가 있습니다. 리뷰는 적어도 뻔한 표준 위반을 방지하는 관문 역할을 합니다. pull request, upsource 등을 이용합니다.

코드 리뷰의 과제는 리뷰어들은 해당 코드의 사전 이해가 적은 경우가 많다. (최상의 리뷰는 코드를 깊이 이해한 사람에게서 나온다)
결과적으로 원하는 바보다 적은 결함을 찾게됨. 교정된 결함의 종류도 일반적인 표면 수준. 또 코드 리뷰 시점이 코드가 이미 만들어진 단계에 하기 때문에 큰 변경을 하기에는 어려움.

### 짝 프로그래밍을 이용한 리뷰

짝 프로그래밍은 소프트웨어 개발 세상에서 많은 논란을 일으킨 주제. 이것은 두 프로그래머가 함께 나란히 앉아서 소프트웨어를 개발하는것입니다. 잘되면 짝 프로그래밍은 그중 한 명이 했을 때보다 설계가 좋고. 한
명보다는 두 명이 함께하는 것이 낫다는 해법 을만듭니다. 짝 프로그래밍 옹호자는 그것이 적극적인 형태의 리뷰라고 주장합니다. 시작부터 품질이 좋은 코드를 만들 수 있다는 희망.

물론 모든 사람에게 긍정적인 것은 아니다. 잘못된 짝 프로그래밍은 도망가고 싶은 기억을 선사하기도 함. 짝 프로그래밍을 하기에 앞서 동료와 룰과 피해야할 몇가지 위험들을 공유.

## 지속적 통합으로 수렴

단위 테스트를 팀 차원의 표준으로 바라보려면 공유 저장소가 필요. 1차적으로 nightly build(혹은 daily build) 수행시 테스트를 추가하여 가치를 극적으로 향상. 단 nightly build는
피드백과 그로인한 대응이 느리다. 지속적인 통합(CI)을 도입 한다면 빠른 피드백을 받을 수있다. 소스 코드 변경 시 빌드와 테스트 수행. CI 서버는 나쁜코드를 용납하지 않도록 건강한 압박을 느끼게 해준다. ->
스스로 단위 테스트를 돌려보게됨. CI 서버의 사용은 환경 구축시 기본 고려사항.

자바와 잘 작동하는 CI 도구

허드슨, 젠킨스, 팀시티, 앤트힐, 크루즈콘드롤, 빌드봇, 뱀부 등.

## 코드 커버리지

코드 커버리지는 단위 테스트가 실행한 코드의 전체 퍼센트를 측정하는 것입니다. 커버리지의 결과가 도구에 따라 다르다고 걱정하지 마세요. 그 숫자는 경향을 보 는 것이지 구체적인 숫자는 중요하지 않습니다.

### 커버리지는 어느 정도여야 하는가?

낮은 커버리지 보다는 높은 코드 커버리지가 좋다고 생각됨. 관리자를 만족시키기 위한 100% 코드 커버리지를 달성 할 수 있을까요? 커버리지 개념은 속임수를 써야만 100% 도달할 수 있다는 제한이 내재되어있음.
대부분의 사람은 (엠마의 제조사를 포함하여) 70% 이하의 커버리지는 불충분 하다고 말합니다. 나머지 30%의 코드에 많은 결함이 존재할 것.

TDD 를 수행하는 개발자들(12장 참고)은 일반적으로 정의상 90%를 초과 달성합니다.

커버리지를 높이기 위해 테스트 코드의 품질을 소흘히 해서는 안됩니다. 커버리지 도구는 단일 단언을 사용했는지 여부를 신경 쓰지 않습니다. 또 여러분은 이해하고 유지 보수하기 어려우며 가치 있는 단언을 포함하지 않은
나쁜 테스트를 작성했을 수도 있습니다. 많은 팀이 높은 커버리지만 달성하고 가치는 별로 없는 단위 테스트를 작성하느라 시간 낭비하는 것을 보았습니다.

코드 커버리지 숫자는 그 자체로 큰 의미가 없습니다. 하지만 코드 커버리지의 추세는 중요합니다. 팀은 시간이 지나면서 커버리지 퍼센트가 높아져야 하고 적어도 아래 방향으로 내려가면 안 됩니다.

코드 커버리지 도구는 코드가 어디에서 커버리지가 부족한지, 팀이 어디에서 아래 방향으로 내려가고 있는지 이해하려고 할 때만사용하세요.